<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' https: data: 'unsafe-inline' 'unsafe-eval'; media-src * data: blob: https:; img-src * data: blob: https:; connect-src * data: blob: https:; frame-src * https: data:; child-src * https: data:;">
  <title>Grok Desktop</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    :root {
      --color-text: #000000;
      --color-bg-toolbar: #F9F8F6;
      --color-bg-tab: #F9F8F6;
      --color-bg-tab-active: #ffffff;
      --color-bg-content: #ffffff;
      --color-border: #dddddd;
      --color-hover: #dddddd;
      --color-aot-border: #cccccc;
      --color-aot-hover: #e6e6e6;
      --scrollbar-track: #f1f1f1;
      --scrollbar-thumb: #c1c1c1;
      --scrollbar-thumb-hover: #a8a8a8;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --color-text: #e6e6e6;
        --color-bg-toolbar: #1e1f22;
        --color-bg-tab: #2b2d31;
        --color-bg-tab-active: #3b3e45;
        --color-bg-content: #2b2d31;
        --color-border: #444444;
        --color-hover: #444444;
        --color-aot-border: #555555;
        --color-aot-hover: #444444;
        --scrollbar-track: #2a2b2f;
        --scrollbar-thumb: #55595f;
        --scrollbar-thumb-hover: #666b73;
      }
    }

    /* Also support JS-driven theme toggling via a class */
    :root.dark {
      --color-text: #e6e6e6;
      --color-bg-toolbar: #1e1f22;
      --color-bg-tab: #2b2d31;
      --color-bg-tab-active: #3b3e45;
      --color-bg-content: #2b2d31;
      --color-border: #444444;
      --color-hover: #444444;
      --color-aot-border: #555555;
      --color-aot-hover: #444444;
      --scrollbar-track: #2a2b2f;
      --scrollbar-thumb: #55595f;
      --scrollbar-thumb-hover: #666b73;
    }

    /* Basic styling for the tabs */
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
      color: var(--color-text);
    }

    .tabs-container {
      width: 100%;
      height: 50px;
      background-color: var(--color-bg-toolbar);
      display: flex;
      overflow: hidden; /* keep controls visible; only tabs scroll */
      position: relative;
    }

    .tabs {
      display: flex;
      flex: 1 1 auto;
      min-width: 0;            /* allow flex child to shrink so it doesn't push controls */
      overflow-x: auto;        /* scroll just the tabs area */
      overflow-y: hidden;
    }

    .tabs-scroll {
      appearance: none;
      -webkit-appearance: none;
      border: none;
      background: none;
      color: var(--color-text);
      font-size: 18px;
      width: 28px;
      height: 40px;
      cursor: pointer;
      align-self: center;
      display: none; /* hidden by default; shown only when needed */
    }
    .tabs-scroll:hover { background-color: var(--color-hover); }
    .tabs-scroll-left { margin-right: 2px; }
    .tabs-scroll-right { margin-left: 2px; }

    .tab {
      display: flex;
      align-items: center;
      border-right: 1px solid var(--color-border);
      min-width: 180px;
      max-width: 220px;
      padding: 0 10px;
      height: 40px;
      background-color: var(--color-bg-tab);
      cursor: pointer;
      overflow: hidden;
      position: relative;
    }

    .tab.active {
      background-color: var(--color-bg-tab-active);
    }

    .tab-title {
      text-overflow: ellipsis;
      white-space: nowrap;
      overflow: hidden;
      margin-right: 20px;
    }

    .tab-close {
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      margin: 0;
      padding: 0;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      font-size: 14px;
      cursor: pointer;
      color: var(--color-text);
    }

    .tab-close:hover {
      background-color: var(--color-hover);
    }

    .new-tab-button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      width: 30px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 5px;
      color: var(--color-text);
    }

    .new-tab-button:hover {
      background-color: var(--color-hover);
    }

    .app-controls {
      display: flex;
      align-items: center;
      padding: 0 5px;
      flex: 0 0 auto;          /* reserve space; never shrink */
      white-space: nowrap;
    }

    .aot-button {
      background: none;
      border: 1px solid var(--color-aot-border);
      border-radius: 4px;
      margin-left: 5px;
      padding: 2px 6px;
      font-size: 12px;
      cursor: pointer;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      color: var(--color-text);
    }

    .aot-button:hover {
      background-color: var(--color-aot-hover);
    }

    .aot-button.active {
      background-color: #4CAF50;
      color: white;
      border-color: #4CAF50;
    }

    .reload-button {
      background: none;
      border: 1px solid var(--color-aot-border);
      border-radius: 4px;
      margin-right: 5px;
      padding: 2px 6px;
      font-size: 16px;
      cursor: pointer;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      color: var(--color-text);
    }

    .reload-button:hover {
      background-color: var(--color-aot-hover);
    }

    .reload-button.loading {
      animation: spin-reload 1s linear infinite;
      pointer-events: none;
      opacity: 0.7;
    }

    @keyframes spin-reload {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .views-container {
      height: calc(100vh - 40px);
      width: 100%;
      position: relative;
      background-color: var(--color-bg-content);
    }

    .view {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      background-color: var(--color-bg-content);
    }

    .view.active {
      display: block;
    }

    webview {
      width: 100%;
      height: 100%;
      border: none;
      background-color: var(--color-bg-content);
    }
  </style>
</head>
<body>
  <div class="tabs-container">
    <button class="tabs-scroll tabs-scroll-left" id="tabs-scroll-left" aria-hidden="true">&#x2039;</button>
    <div class="tabs" id="tabs"></div>
    <button class="tabs-scroll tabs-scroll-right" id="tabs-scroll-right" aria-hidden="true">&#x203A;</button>
    <div class="app-controls">
  <div id="update-indicator" style="margin-right:8px;font-size:12px;opacity:0.9;cursor:pointer;text-decoration:underline;display:none;"></div>
  <button class="reload-button" id="reload-button" title="Reload current tab">↻</button>
  <button class="aot-button" id="aot-button" title="Always on top">AOT</button>
  <button class="aot-button" id="update-btn" style="margin-left:8px;display:none;background:#ff3333;color:#fff;border-color:#cc0000;" title="Update available">↑</button>
  <button class="aot-button" id="info-btn" style="margin-left:8px;" title="About">i</button>
    </div>
  </div>
  <div class="views-container" id="views"></div>

  <script>
    // Simple tab management
    const { ipcRenderer } = require('electron');
    const https = require('https');
    const currentVersionPromise = ipcRenderer.invoke('get-app-version');

    function parseTagName(tag) {
      if (!tag) return null;
      // expect vMAJOR.MINOR.PATCH
      const m = tag.trim().match(/^v?(\d+)\.(\d+)\.(\d+)$/);
      if (!m) return null;
      return { major: +m[1], minor: +m[2], patch: +m[3] };
    }

    function cmpSemver(a, b) {
      if (a.major !== b.major) return a.major - b.major;
      if (a.minor !== b.minor) return a.minor - b.minor;
      return a.patch - b.patch;
    }

    let latestReleaseUrl = null;

    async function checkForUpdate() {
      try {
        const currentVersionStr = await currentVersionPromise;
        const cur = parseTagName('v' + currentVersionStr);
        if (!cur) return;
        const data = await fetchLatestRelease();
        if (!data || !data.tag_name) return;
        const latest = parseTagName(data.tag_name);
        if (!latest) return;
        if (cmpSemver(latest, cur) > 0) {
          const el = document.getElementById('update-indicator');
          const btn = document.getElementById('update-btn');
          latestReleaseUrl = data.html_url || `https://github.com/AnRkey/Grok-Desktop/releases/tag/${data.tag_name}`;
          if (btn) {
            btn.style.display = 'inline-block';
            btn.title = `Version ${data.tag_name} available`;
          }

        }
      } catch (_) {}
    }

    function fetchLatestRelease() {
      const url = 'https://api.github.com/repos/AnRkey/Grok-Desktop/releases/latest';
      const headers = { 'User-Agent': 'Grok-Desktop', 'Accept': 'application/vnd.github+json' };
      return new Promise((resolve, reject) => {
        const req = https.get(url, { headers }, (res) => {
          let body = '';
          res.on('data', (chunk) => body += chunk);
          res.on('end', () => {
            try {
              resolve(JSON.parse(body));
            } catch (e) {
              resolve(null);
            }
          });
        });
        req.on('error', reject);
        req.end();
      });
    }

    // Apply theme on message from main
    ipcRenderer.on('system-theme-updated', (_event, theme) => {
      if (theme === 'dark') {
        document.documentElement.classList.add('dark');
      } else {
        document.documentElement.classList.remove('dark');
      }
    });

    const tabManager = {
      tabs: [],
      activeTabId: null,
      tabsContainer: document.getElementById('tabs'),
      viewsContainer: document.getElementById('views'),
      newTabButton: null,
      
      init() {
        // Create the new tab button
        this.createNewTabButton();
        
        // Set up reload button
        const reloadButton = document.getElementById('reload-button');
        reloadButton.addEventListener('click', () => {
          const activeTab = this.tabs.find(tab => tab.id === this.activeTabId);
          if (activeTab && activeTab.webview) {
            // Add loading state
            reloadButton.classList.add('loading');

            // Remove loading state when page finishes loading
            const removeLoading = () => {
              reloadButton.classList.remove('loading');
              activeTab.webview.removeEventListener('did-stop-loading', removeLoading);
            };
            activeTab.webview.addEventListener('did-stop-loading', removeLoading);

            // Reload the webview (after listener is attached)
            activeTab.webview.reload();
          }
        });
        
        // Set up AOT button
        const aotButton = document.getElementById('aot-button');
        aotButton.addEventListener('click', () => {
          // Use IPC to communicate with the main process
          ipcRenderer.invoke('toggle-always-on-top').then((isAlwaysOnTop) => {
            if (isAlwaysOnTop) {
              aotButton.classList.add('active');
            } else {
              aotButton.classList.remove('active');
            }
          });
        });
        
        // Create initial tab
        this.createTab('https://grok.com');

        // After initial UI is ready, check for updates
        checkForUpdate();

        // Setup tab scroll buttons visibility and behavior
        this.setupScrollButtons();
      },
      
      createNewTabButton() {
        // Create the new tab button if it doesn't exist
        if (!this.newTabButton) {
          this.newTabButton = document.createElement('button');
          this.newTabButton.className = 'new-tab-button';
          this.newTabButton.textContent = '+';
          this.newTabButton.addEventListener('click', () => {
            this.createTab('https://grok.com');
          });
        }
        
        // Add it to the tabs container
        this.tabsContainer.appendChild(this.newTabButton);
      },
      
      updateNewTabButtonPosition() {
        // Move the new tab button to the end of the tabs list
        if (this.newTabButton && this.newTabButton.parentNode) {
          this.newTabButton.parentNode.removeChild(this.newTabButton);
        }
        this.tabsContainer.appendChild(this.newTabButton);
        // Re-evaluate scroll buttons after tab changes
        this.updateScrollButtons();
      },
      
      createTab(url) {
        const tabId = 'tab-' + Date.now();
        
        // Create tab element
        const tabElement = document.createElement('div');
        tabElement.className = 'tab';
        tabElement.id = tabId;
        tabElement.innerHTML = `
          <div class="tab-title">New Tab</div>
          <button class="tab-close">×</button>
        `;
        
        // Create view element with webview
        const viewElement = document.createElement('div');
        viewElement.className = 'view';
        viewElement.id = 'view-' + tabId;
        
        const webview = document.createElement('webview');
        webview.src = url;
        webview.partition = 'persist:grok';
        webview.setAttribute('allowpopups', '');
        webview.setAttribute('allow', 'microphone; camera; autoplay; clipboard-read; clipboard-write; display-capture');
        
        viewElement.appendChild(webview);

        const ensureWebviewBackground = () => {
          const bg = getComputedStyle(webview).backgroundColor;
          if (bg === 'rgba(0, 0, 0, 0)' || bg === 'transparent') {
            webview.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--color-bg-content').trim() || '#ffffff';
          }
        };
        ensureWebviewBackground();

        const applyAppleLightScheme = async () => {
          let currentUrl = '';
          try { currentUrl = webview.getURL ? webview.getURL() : ''; } catch (_) {}
          const target = (currentUrl || '').toLowerCase();
          const wcId = webview.getWebContentsId ? webview.getWebContentsId() : null;
          if (wcId && (target.includes('appleid.apple.com') || target.includes('appleid.apple.com/auth'))) {
            try { await ipcRenderer.invoke('force-light-color-scheme', wcId, true); } catch (_) {}
            // Fallback CSS to force light palette in case site ignores color scheme
            const lightCss = `:root{color-scheme:light !important}
              html,body{background:#ffffff !important;color:#000000 !important}
              input,textarea,select{background:#ffffff !important;color:#000000 !important;border-color:#bbb !important}
              header,nav{background:#ffffff !important;color:#000000 !important}
            `;
            try { webview.insertCSS(lightCss).catch(()=>{}); } catch (_) {}
            webview.style.backgroundColor = '#ffffff';
          } else if (wcId) {
            try { await ipcRenderer.invoke('force-light-color-scheme', wcId, false); } catch (_) {}
            // Reset background to themed content color
            webview.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--color-bg-content').trim() || '';
          }
        };
        
        // Add to DOM - insert before the new tab button
        this.tabsContainer.appendChild(tabElement);
        this.viewsContainer.appendChild(viewElement);
        
        // Update the new tab button position
        this.updateNewTabButtonPosition();
        
        // Set up event listeners
        tabElement.addEventListener('click', (e) => {
          if (!e.target.classList.contains('tab-close')) {
            this.activateTab(tabId);
          }
        });
        
        tabElement.querySelector('.tab-close').addEventListener('click', () => {
          this.closeTab(tabId);
        });
        
        // Set up webview events
        webview.addEventListener('page-title-updated', (e) => {
          const titleElement = tabElement.querySelector('.tab-title');
          titleElement.textContent = e.title;
          titleElement.title = e.title;
        });
        
        webview.addEventListener('did-start-loading', () => {
          tabElement.classList.add('loading');
        });
        
        webview.addEventListener('did-stop-loading', () => {
          tabElement.classList.remove('loading');
        });

        webview.addEventListener('dom-ready', () => {
          ensureWebviewBackground();
          applyAppleLightScheme();
        });

        webview.addEventListener('did-navigate', () => applyAppleLightScheme());
        webview.addEventListener('did-navigate-in-page', () => applyAppleLightScheme());
        
        const handleOpenUrl = (targetUrl) => {
          const url = targetUrl;
          const internalPatterns = [
            /.*\.grok\.com.*/,
            /.*\.x\.ai.*/,
            /.*accounts\.google\.com.*/,
            /.*appleid\.apple\.com.*/
          ];
          // Explicitly treat auth/navigation endpoints as internal and navigate in same tab
          if (/^https?:\/\/grok\.com\/sign-in(\b|\/|\?|#)/i.test(url)
           || /^https?:\/\/grok\.com\/sign-out(\b|\/|\?|#)/i.test(url)
           || /^https?:\/\/accounts\.x\.ai\/sign-in(\b|\/|\?|#)/i.test(url)) {
            if (typeof webview.loadURL === 'function') {
              webview.loadURL(url);
            } else {
              webview.src = url;
            }
            return;
          }

          const isInternalUrl = internalPatterns.some(pattern => pattern.test(url));

          if (isInternalUrl) {
            if (typeof webview.loadURL === 'function') {
              webview.loadURL(url);
            } else {
              webview.src = url;
            }
          } else {
            require('electron').shell.openExternal(url);
          }
        };

        // Open links that request a new window
        webview.addEventListener('new-window', (e) => { e.preventDefault(); handleOpenUrl(e.url); });
        // Allow internal same-tab nav; open external in browser
        webview.addEventListener('will-navigate', (e) => {
          const url = e.url;
          const internal = /.*\.grok\.com.*/.test(url) ||
                           /.*\.x\.ai.*/.test(url) ||
                           /.*accounts\.google\.com.*/.test(url) ||
                           /.*appleid\.apple\.com.*/.test(url) ||
                           /^https?:\/\/grok\.com\/sign-in(\b|\/|\?|#)/i.test(url) ||
                           /^https?:\/\/grok\.com\/sign-out(\b|\/|\?|#)/i.test(url) ||
                           /^https?:\/\/accounts\.x\.ai\/sign-in(\b|\/|\?|#)/i.test(url);
          if (!internal) {
            e.preventDefault();
            require('electron').shell.openExternal(url);
          }
        });
        
        // Store tab info
        this.tabs.push({
          id: tabId,
          element: tabElement,
          view: viewElement,
          webview: webview
        });
        
        // Activate the new tab
        this.activateTab(tabId);
        
        return tabId;
      },

      activateNextTab() {
        if (!this.tabs.length) return;
        if (!this.activeTabId) {
          this.activateTab(this.tabs[0].id);
          return;
        }
        const currentIndex = this.tabs.findIndex(t => t.id === this.activeTabId);
        const nextIndex = (currentIndex + 1) % this.tabs.length;
        this.activateTab(this.tabs[nextIndex].id);
      },

      activatePrevTab() {
        if (!this.tabs.length) return;
        if (!this.activeTabId) {
          this.activateTab(this.tabs[0].id);
          return;
        }
        const currentIndex = this.tabs.findIndex(t => t.id === this.activeTabId);
        const prevIndex = (currentIndex - 1 + this.tabs.length) % this.tabs.length;
        this.activateTab(this.tabs[prevIndex].id);
      },

      reloadActiveTab() {
        const activeTab = this.tabs.find(tab => tab.id === this.activeTabId);
        if (!activeTab || !activeTab.webview) return;
        const reloadButton = document.getElementById('reload-button');
        if (reloadButton) {
          reloadButton.classList.add('loading');
          const removeLoading = () => {
            reloadButton.classList.remove('loading');
            activeTab.webview.removeEventListener('did-stop-loading', removeLoading);
          };
          activeTab.webview.addEventListener('did-stop-loading', removeLoading);
        }
        activeTab.webview.reload();
      },

      setupScrollButtons() {
        this.leftBtn = document.getElementById('tabs-scroll-left');
        this.rightBtn = document.getElementById('tabs-scroll-right');
        this.scrollContainer = this.tabsContainer; // tabs container is the scroll target for x
        if (this.leftBtn && this.rightBtn) {
          this.leftBtn.addEventListener('click', () => this.scrollByAmount(-200));
          this.rightBtn.addEventListener('click', () => this.scrollByAmount(200));
          // Update on scroll and resize
          this.scrollContainer.addEventListener('scroll', () => this.updateScrollButtons(), { passive: true });
          window.addEventListener('resize', () => this.updateScrollButtons());
          // Initial
          this.updateScrollButtons();
        }
      },

      scrollByAmount(dx) {
        this.scrollContainer.scrollBy({ left: dx, behavior: 'smooth' });
      },

      updateScrollButtons() {
        if (!this.leftBtn || !this.rightBtn) return;
        const sc = this.scrollContainer;
        const canScrollLeft = sc.scrollLeft > 0;
        const canScrollRight = Math.ceil(sc.scrollLeft + sc.clientWidth) < sc.scrollWidth;
        this.leftBtn.style.display = canScrollLeft ? 'inline-flex' : 'none';
        this.rightBtn.style.display = canScrollRight ? 'inline-flex' : 'none';
      },
      
      activateTab(tabId) {
        // Deactivate current active tab
        if (this.activeTabId) {
          const activeTab = this.tabs.find(tab => tab.id === this.activeTabId);
          if (activeTab) {
            activeTab.element.classList.remove('active');
            activeTab.view.classList.remove('active');
          }
        }
        
        // Activate new tab
        const tab = this.tabs.find(tab => tab.id === tabId);
        if (tab) {
          tab.element.classList.add('active');
          tab.view.classList.add('active');
          this.activeTabId = tabId;
        }
      },
      
      closeTab(tabId) {
        const tabIndex = this.tabs.findIndex(tab => tab.id === tabId);
        
        if (tabIndex !== -1) {
          const tab = this.tabs[tabIndex];
          
          // Remove from DOM
          tab.element.remove();
          tab.view.remove();
          
          // Remove from tabs array
          this.tabs.splice(tabIndex, 1);
          
          // If this was the active tab, activate another one
          if (this.activeTabId === tabId) {
            if (this.tabs.length > 0) {
              // Activate the tab to the left, or the first tab if this was the leftmost
              const newActiveIndex = Math.max(0, tabIndex - 1);
              this.activateTab(this.tabs[newActiveIndex].id);
            } else {
              this.activeTabId = null;
            }
          }
          
          // If no tabs left, create a new one
          if (this.tabs.length === 0) {
            this.createTab('https://grok.com');
          } else {
            // Update the new tab button position
            this.updateNewTabButtonPosition();
          }
        }
      }
    };
    
    // Global shortcut handlers from main process
    ipcRenderer.on('shortcut-new-tab', () => {
      tabManager.createTab('https://grok.com');
    });
    ipcRenderer.on('shortcut-next-tab', () => {
      tabManager.activateNextTab();
    });
    ipcRenderer.on('shortcut-prev-tab', () => {
      tabManager.activatePrevTab();
    });
    ipcRenderer.on('shortcut-reload-tab', () => {
      tabManager.reloadActiveTab();
    });
    
    // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      tabManager.init();
      // Click to open latest release page
      const indicator = document.getElementById('update-indicator');
      if (indicator) {
        indicator.addEventListener('click', () => {
          const url = latestReleaseUrl || 'https://github.com/AnRkey/Grok-Desktop/releases/latest';
          if (window.ipcRenderer) {
            window.ipcRenderer.invoke('open-external-url', url);
          } else if (typeof ipcRenderer !== 'undefined') {
            ipcRenderer.invoke('open-external-url', url);
          }
        });
      }
      const updateBtn = document.getElementById('update-btn');
      if (updateBtn) {
        updateBtn.addEventListener('click', () => {
          const url = latestReleaseUrl || 'https://github.com/AnRkey/Grok-Desktop/releases/latest';
          if (window.ipcRenderer) {
            window.ipcRenderer.invoke('open-external-url', url);
          } else if (typeof ipcRenderer !== 'undefined') {
            ipcRenderer.invoke('open-external-url', url);
          }
        });
      }
      const infoBtn = document.getElementById('info-btn');
      if (infoBtn) {
        infoBtn.addEventListener('click', () => {
          if (window.ipcRenderer) {
            window.ipcRenderer.invoke('show-app-info');
          } else if (typeof ipcRenderer !== 'undefined') {
            ipcRenderer.invoke('show-app-info');
          }
        });
      }
    });
  </script>
</body>
</html> 